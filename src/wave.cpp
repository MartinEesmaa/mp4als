/***************** MPEG-4 Audio Lossless Coding **************************

This software module was originally developed by

Tilman Liebchen (Technical University of Berlin)

in the course of development of the MPEG-4 Audio standard ISO/IEC 14496-3
and associated amendments. This software module is an implementation of
a part of one or more MPEG-4 Audio lossless coding tools as specified
by the MPEG-4 Audio standard. ISO/IEC gives users of the MPEG-4 Audio
standards free license to this software module or modifications
thereof for use in hardware or software products claiming conformance
to the MPEG-4 Audio standards. Those intending to use this software
module in hardware or software products are advised that this use may
infringe existing patents. The original developer of this software
module, the subsequent editors and their companies, and ISO/IEC have
no liability for use of this software module or modifications thereof
in an implementation. Copyright is not released for non MPEG-4 Audio
conforming products. The original developer retains full right to use
the code for the developer's own purpose, assign or donate the code to
a third party and to inhibit third party from using the code for non
MPEG-4 Audio conforming products. This copyright notice must be included
in all copies or derivative works.

Copyright (c) 2003.

filename : wave.cpp
project  : MPEG-4 Audio Lossless Coding
author   : Tilman Liebchen (Technical University of Berlin)
date     : June 16, 2003
contents : Wave file header I/O

*************************************************************************/

/*************************************************************************
 *
 * Modifications:
 *
 * 11/11/2003, Tilman Liebchen <liebchen@nue.tu-berlin.de>
 *   added support for AIFF and other file formats
 *   - added GetAiffFormat() and helper functions
 *   - added void [Write/Read]U[Short/Long]MSBfirst() functions
 *
 * 1/26/2005, Noboru Harada <n-harada@theory.brl.ntt.co.jp>
 *   added support unknown chunks for wave files generated by Cubase
 *
 *************************************************************************/

#include <stdio.h>
#include <string.h>

#include "wave.h"

short GetWaveFormatPCM(FILE *wav, WAVEFORMATPCM *wf, ULONG *samples)
{
	char RiffChunkRef[4] = {'R', 'I', 'F', 'F'};
	char WaveChunkRef[4] = {'W', 'A', 'V', 'E'};
	char FormChunkRef[4] = {'f', 'm', 't', ' '};
	char DataChunkRef[4] = {'d', 'a', 't', 'a'};

	//char RiffChunk[4], WaveChunk[4], FormChunk[4], DataChunk[4];
	char RiffChunk[4], WaveChunk[4];
	char ChunkBuf[4];
	ULONG RiffLen, FormLen, DataLen, ChunkLen, ChunkLenSum, i;

	// Read file header

	// 'RIFF'
	fread(RiffChunk, 1, 4, wav);
	if (memcmp(RiffChunk, RiffChunkRef, 4) != 0)
		return(-1);
	RiffLen = ReadULongLSBfirst(wav);

	// 'WAVE'
	fread(WaveChunk, 1, 4, wav);
	if (memcmp(WaveChunk, WaveChunkRef, 4) != 0)
		return(-2);

	// 'fmt '
	//fread(FormChunk, 1, 4, wav);
	ChunkLenSum = FormLen = 0;
	fread(ChunkBuf, 1, 4, wav);
	while(memcmp(ChunkBuf, DataChunkRef, 4) != 0) {
		if (memcmp(ChunkBuf, FormChunkRef, 4) != 0) {
			//unknown chank befor fmt
			ChunkLen = ReadULongLSBfirst(wav);
			for(i=0;i<ChunkLen;i++)
				fread(ChunkBuf, 1, 1, wav);
			ChunkLenSum += (ChunkLen + 8);
			fread(ChunkBuf, 1, 4, wav);
		} else {
			FormLen = ReadULongLSBfirst(wav);

			// WAVEFORMATPCM
			wf->FormatTag = ReadUShortLSBfirst(wav);
			wf->Channels = ReadUShortLSBfirst(wav);
			wf->SamplesPerSec = ReadULongLSBfirst(wav);
			wf->AvgBytesPerSec = ReadULongLSBfirst(wav);
			wf->BlockAlign = ReadUShortLSBfirst(wav);
			wf->BitsPerSample = ReadUShortLSBfirst(wav);

			if ((wf->FormatTag != 1) && (wf->FormatTag != 3))
				return(-4);
			if (FormLen > 16)
				fseek(wav, FormLen - 16, SEEK_CUR);
			fread(ChunkBuf, 1, 4, wav);
		}
	}

	// 'data'
	//fread(DataChunk, 1, 4, wav);
	DataLen = ReadULongLSBfirst(wav);
	if (memcmp(ChunkBuf, DataChunkRef, 4) != 0)	// Additional unknown chunk
	{
		fseek(wav, DataLen, SEEK_CUR);
		FormLen += DataLen + 8;						// Add size of unknown chunk
		fread(ChunkBuf, 1, 4, wav);
		DataLen = ReadULongLSBfirst(wav);
		if (memcmp(ChunkBuf, DataChunkRef, 4) != 0)
			return(-5);
	}

	*samples = DataLen / wf->BlockAlign;		// Samples (per channel)

	return(short(FormLen + ChunkLenSum + 28));				// Length of header (in bytes)
}

short WriteWaveHeaderPCM(FILE *wav, WAVEFORMATPCM *wf, ULONG *samples)
{
	WAVEFILEHEADER header;
	ULONG size;

	size = *samples * wf->BlockAlign;	// Size of samples (bytes)
	
	// Generate header
	strcpy(header.RiffChunk, "RIFF");
	header.RiffLen = size + sizeof(header) - 8;
	strcpy(header.WaveChunk, "WAVE") ;
	strcpy(header.FormChunk, "fmt ") ;
	header.FormLen = 16 ;
	header.wf.FormatTag = wf->FormatTag;
	header.wf.Channels = wf->Channels;
	header.wf.SamplesPerSec = wf->SamplesPerSec;
	header.wf.AvgBytesPerSec = wf->AvgBytesPerSec;
	header.wf.BlockAlign = wf->BlockAlign;
	header.wf.BitsPerSample = wf->BitsPerSample;
	strcpy(header.DataChunk, "data");
	header.DataLen = size;

	// Write header
	fwrite(&header, sizeof(header), 1, wav) ;

	return(0);
}

void WriteUShortLSBfirst(unsigned short x, FILE *fp)
{
	unsigned char tmp[2];

	tmp[1] = (unsigned char)((x & 0x0000FF00) >> 8);
	tmp[0] = (unsigned char) (x & 0x000000FF);

	fwrite(tmp, 1, 2, fp);
}

void WriteUShortMSBfirst(unsigned short x, FILE *fp)
{
	unsigned char tmp[2];

	tmp[0] = (unsigned char)((x & 0x0000FF00) >> 8);
	tmp[1] = (unsigned char) (x & 0x000000FF);

	fwrite(tmp, 1, 2, fp);
}

unsigned short ReadUShortLSBfirst(FILE *fp)
{
	unsigned char tmp[2];

	fread(tmp, 1, 2, fp);

	return(((unsigned short)tmp[1] << 8) + (unsigned short)tmp[0]);
}

unsigned short ReadUShortMSBfirst(FILE *fp)
{
	unsigned char tmp[2];

	fread(tmp, 1, 2, fp);

	return(((unsigned short)tmp[0] << 8) + (unsigned short)tmp[1]);
}

void WriteULongLSBfirst(unsigned long x, FILE *fp)
{
	unsigned char tmp[4];

	tmp[3] = (unsigned char)((x & 0xFF000000) >> 24);
	tmp[2] = (unsigned char)((x & 0x00FF0000) >> 16);
	tmp[1] = (unsigned char)((x & 0x0000FF00) >> 8);
	tmp[0] = (unsigned char) (x & 0x000000FF);

	fwrite(tmp, 1, 4, fp);
}

void WriteULongMSBfirst(unsigned long x, FILE *fp)
{
	unsigned char tmp[4];

	tmp[0] = (unsigned char)((x & 0xFF000000) >> 24);
	tmp[1] = (unsigned char)((x & 0x00FF0000) >> 16);
	tmp[2] = (unsigned char)((x & 0x0000FF00) >> 8);
	tmp[3] = (unsigned char) (x & 0x000000FF);

	fwrite(tmp, 1, 4, fp);
}

unsigned long ReadULongLSBfirst(FILE *fp)
{
	unsigned char tmp[4];

	fread(tmp, 1, 4, fp);

	return(((unsigned long)tmp[3] << 24) + ((unsigned long)tmp[2] << 16)
		+ ((unsigned long)tmp[1] << 8) + (unsigned long)tmp[0]);
}

unsigned long ReadULongMSBfirst(FILE *fp)
{
	unsigned char tmp[4];

	fread(tmp, 1, 4, fp);

	return(((unsigned long)tmp[0] << 24) + ((unsigned long)tmp[1] << 16)
		+ ((unsigned long)tmp[2] << 8) + (unsigned long)tmp[3]);
}

void FlipLong(unsigned char * ptr)
{
   register unsigned char val;

   /* Swap 1st and 4th bytes */
   val = *(ptr);
   *(ptr) = *(ptr+3);
   *(ptr+3) = val;

   /* Swap 2nd and 3rd bytes */
   ptr += 1;
   val = *(ptr);
   *(ptr) = *(ptr+1);
   *(ptr+1) = val;
}

unsigned long ConvertFloat(unsigned char *buffer)
{
	unsigned long mantissa;
	unsigned long last = 0;
	unsigned char exp;

	FlipLong(buffer+2);

	mantissa = *((unsigned long *)(buffer+2));
	exp = 30 - *(buffer+1);
	while (exp--)
	{
		last = mantissa;
		mantissa >>= 1;
	}
	if (last & 0x00000001)
		mantissa++;

	return(mantissa);
}

short GetAiffFormat(FILE *aif, AIFFCOMMON *ac, ULONG *Offset, ULONG *BlockSize, ULONG *samplerate)
{
	char FormChunkRef[4] = {'F', 'O', 'R', 'M'};
	char AiffChunkRef[4] = {'A', 'I', 'F', 'F'};
	char CommChunkRef[4] = {'C', 'O', 'M', 'M'};
	char SsndChunkRef[4] = {'S', 'S', 'N', 'D'};
	char FormChunk[4], AiffChunk[4], CommChunk[4], SsndChunk[4];
	ULONG FormLen, CommLen, SsndLen;

	// Read file header

	// 'FORM'
	fread(FormChunk, 1, 4, aif);
	if (memcmp(FormChunk, FormChunkRef, 4) != 0)
		return(-1);
	FormLen = ReadULongMSBfirst(aif);

	// 'AIFF'
	fread(AiffChunk, 1, 4, aif);
	if (memcmp(AiffChunk, AiffChunkRef, 4) != 0)
		return(-2);

	// 'COMM'
	fread(CommChunk, 1, 4, aif);
	if (memcmp(CommChunk, CommChunkRef, 4) != 0)
		return(-3);
	CommLen = ReadULongMSBfirst(aif);

	// AIFFCOMMON
	ac->Channels = ReadUShortMSBfirst(aif);
	ac->SampleFrames = ReadULongMSBfirst(aif);
	ac->SampleSize = ReadUShortMSBfirst(aif);
	fread(ac->SampleRate, 1, 10, aif);

	if (CommLen > 18)
		fseek(aif, CommLen - 18, SEEK_CUR);

	// 'SSND'
	fread(SsndChunk, 1, 4, aif);
	SsndLen = ReadULongMSBfirst(aif);
	if (memcmp(SsndChunk, SsndChunkRef, 4) != 0)
		return(-5);

	*Offset = ReadULongMSBfirst(aif);
	*BlockSize = ReadULongMSBfirst(aif);

	// Convert sample rate value from 80-bit float to unsigned long
	BYTE *buffer = ac->SampleRate;

#define INTEL	// Comment out on "big endian" CPUs
#ifdef INTEL
	// Swap 1st <-> 4th and 2nd <-> 3rd bytes
	BYTE *ptr = buffer + 2;
	BYTE val = *(ptr);
	*(ptr) = *(ptr+3);
	 *(ptr+3) = val;
	ptr += 1;
	val = *(ptr); 
	*(ptr) = *(ptr+1);
	*(ptr+1) = val;
#endif

	ULONG last = 0;
	ULONG mantissa = *((unsigned long *)(buffer+2));
	BYTE exp = 30 - *(buffer+1);
	while (exp--)
	{
		last = mantissa;
		mantissa >>= 1;
	}
	if (last & 0x00000001)
		mantissa++;

	*samplerate = mantissa;				// Sample rate in Hz		

	return(short(CommLen + 36));		// Length of header (in bytes)
}
